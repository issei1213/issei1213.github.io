<!doctype html><html lang=ja-jp>
<head>
<meta name=generator content="Hugo 0.91.2"><title>
TechBlog</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name=description content="A description for the meta tag of the site">
<meta property="og:title" content="TechBlog">
<meta property="og:description" content="A description for the meta tag of the site">
<meta property="og:type" content="website">
<meta property="og:url" content="https://issei1213.github.io/">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="TechBlog">
<meta name=twitter:description content="A description for the meta tag of the site">
<meta itemprop=name content="TechBlog">
<meta itemprop=description content="A description for the meta tag of the site">
<link rel=canonical href=https://issei1213.github.io/>
<link rel=icon type=image/png href=https://issei1213.github.io//img/favicon.png>
<link rel=stylesheet href=/css/font-awesome.min.css>
<link rel=stylesheet href=/css/bulma.min.css>
<script src=/js/ramium.js></script>
<link rel=stylesheet href=/css/ramium.css>
</head>
<body><nav class="navbar is-dark" role=navigation aria-label="main navigation">
<div class=navbar-brand>
<a class=navbar-item href=/>
<strong>TechBlog </strong>
</a>
<a role=button class="navbar-burger burger" aria-label=menu aria-expanded=false data-target=navbarBasicExample>
<span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span>
</a>
</div>
<div id=navbarBasicExample class=navbar-menu>
<div class=navbar-start>
<a class=navbar-item href=/>ホーム</a>
<div class="navbar-item has-dropdown is-hoverable">
<a class=navbar-link>ブログ</a>
<div class=navbar-dropdown>
<a class=navbar-item href=/tags/>タグ</a>
<a class=navbar-item href=/posts/>記事</a>
</div>
</div>
</div>
<div class=navbar-end>
<a class="navbar-item navgithub" href=https://github.com/issei1213 target=_blank>
<i class="fa fa-github fa-2x"></i>
</a>
<a class="navbar-item navgithub" href=https://twitter.com/abIOELEsEfu6Os0 target=_blank>
<i class="fa brands fa-twitter fa-2x"></i>
</a>
</div>
</div>
</nav>
<section class="hero has-text-centered">
<div class=hero-body>
<div class=container>
<h1 class="title is-2">
TechBlog
</h1>
</div>
</div>
</section>
<div class="columns is-centered has-text-centered">
<div class="column is-10">
<div class=content>
<p class=tags-summary>
<a href=/tags/typescript>
<span class="tag is-dark is-large is-rounded">
Typescript
</span>
</a>
<a href=/tags/vue.js>
<span class="tag is-dark is-large is-rounded">
Vue.js
</span>
</a>
</p>
</div>
</div>
</div>
<br>
<div class="columns is-centered">
<div class="column is-7">
<div class=blog-brief>
<a href=/posts/typescript_tip-1/>
<h3 class="title is-4">
TypeScript Tip #1
</h3>
</a>
<div class="level is-mobile details">
<div class=level-left>
<div class=level-item>
<a href=/posts/typescript_tip-1/>
<p class="subtitle info date">Apr 7, 2022
</p>
</a>
</div>
<div class=level-item>
<a href=/posts/typescript_tip-1/>
<p class="subtitle info">
6 mins read
</p>
</a>
</div>
</div>
<div class="level-right is-hidden-touch">
<a class="tag is-rounded" href=/tags/typescript>TypeScript</a>
</div>
</div>
<div>
<div>
<a href=/posts/typescript_tip-1/>
<p class=summary>
背景 前回のmattさんのTypeScript Tip #15が勉強になったので、最初から#1からまとめていく
概要 export const fruitCounts = { apple: 1, pear: 4, banana: 26 } 上記の様なコードがあった時に、特定のキーを取得する型エイリアスで定義すると以下になる。
type SingleFruitCount = | { apple: number } | { banana: number } | { pear: number } const singleFruitCount: SingleFruitCount = { apple: 10, } SingleFruitCountの型エイリアスを作成すれば、型定義できるが定数fruitCountsを型推論させて型エイリアスを作成する。
本題 最終的なコードは以下になる。具体的に解説していく。
type FruitCounts = typeof fruitCounts type NewSingleFruitCount = { [ K in keyof FruitCounts ]: { [ K2 in K ]: number } }[keyof FruitCounts] // type NewSingleFruitCount = { // apple: number; // } | { // pear: number; // } | { // banana: number; // } typeof fruitCountsは型推論が効いて以下の型が作成される。 type FruitCounts = { apple: number; pear: number; banana: number; } [ K in keyof FruitCounts ]のkeyof FruitCountsは型エイリアスのオブジェクトのキーのみを取得することができる。
</p>
</a>
</div>
</div>
<div class="level is-mobile continue-reading">
<div class=level-left>
</div>
<div class=level-right>
<a href=/posts/typescript_tip-1/>続きを読む <i class="fa fa-angle-double-right" aria-hidden=true></i></a>
</div>
</div>
<hr>
</div><div class=blog-brief>
<a href=/posts/typescript_react-sample-code-reading/>
<h3 class="title is-4">
りあクトのTypeScriptサンプルコードリーディング
</h3>
</a>
<div class="level is-mobile details">
<div class=level-left>
<div class=level-item>
<a href=/posts/typescript_react-sample-code-reading/>
<p class="subtitle info date">Apr 2, 2022
</p>
</a>
</div>
<div class=level-item>
<a href=/posts/typescript_react-sample-code-reading/>
<p class="subtitle info">
7 mins read
</p>
</a>
</div>
</div>
<div class="level-right is-hidden-touch">
<a class="tag is-rounded" href=/tags/typescript>TypeScript</a>
</div>
</div>
<div>
<div>
<a href=/posts/typescript_react-sample-code-reading/>
<p class=summary>
背景 TypeScriptの教材で以下のサンプルコードがあったので、コードリーディングしていく。
概要 以下のコードリーディングをしていく。
非同期データ取得関数をラップして、そこで起きる例外をフォローしつつ正常系と異常系に振り分ける関数を定義している。
type Result&lt;T, E extends Error> = Ok&lt;T, E> | Err&lt;T, E> export class Ok&lt;T, E extends Error> { constructor(readonly val: T) {} isOk = (): this is Ok&lt;T, E> => true isErr = (): this is Err&lt;T, E> => false } export class Err&lt;T, E extends Error> { constructor(readonly err: E) {} isOk = (): this is Ok&lt;T, E> => false isErr = (): this is Err&lt;T, E> => true } export const withResult = &lt;T, A extends any[], E extends Error>(fn: (.
</p>
</a>
</div>
</div>
<div class="level is-mobile continue-reading">
<div class=level-left>
</div>
<div class=level-right>
<a href=/posts/typescript_react-sample-code-reading/>続きを読む <i class="fa fa-angle-double-right" aria-hidden=true></i></a>
</div>
</div>
<hr>
</div><div class=blog-brief>
<a href=/posts/typescript_tip-15/>
<h3 class="title is-4">
TypeScript Tip #15
</h3>
</a>
<div class="level is-mobile details">
<div class=level-left>
<div class=level-item>
<a href=/posts/typescript_tip-15/>
<p class="subtitle info date">Apr 1, 2022
</p>
</a>
</div>
<div class=level-item>
<a href=/posts/typescript_tip-15/>
<p class="subtitle info">
6 mins read
</p>
</a>
</div>
</div>
<div class="level-right is-hidden-touch">
<a class="tag is-rounded" href=/tags/typescript>TypeScript</a>
</div>
</div>
<div>
<div>
<a href=/posts/typescript_tip-15/>
<p class=summary>
背景 Twitterを眺めていると汎用性が高そうな関数を作成できるTypeScriptのツイートがあったので、整理するためにまとめる。
TypeScript Tip #15 概要 関数の引数のタイプをみて、タイプに応じてpayloadが必要か必要がないかをTypeScriptで判断する。
// 第一引数がSIGN_OUTの場合は、payloadはなし sendEvent('SIGN_OUT') // 第一引数がLOG_INの場合は、payloadは必須 sendEvent("LOG_IN", { userId: '123' }) 成功パターン
sendEvent('SIGN_OUT') sendEvent("LOG_IN", { userId: '123' }) 失敗パターン(コンパイルエラー)
sendEvent('SIGN_OUT', {}) sendEvent('LOG_IN', { userId: 122 }) sendEvent('LOG_IN', {}) sendEvent('LOG_IN') 本題 以下のコードで実現可能
type AuthEvent = | { type: 'LOG_IN' payload: { userId: string } } | { type: 'SIGN_OUT' } const sendEvent = &lt;Type extends AuthEvent['type']>( ...args: Extract&lt;AuthEvent, { type: Type }> extends { payload: infer TPayload } ?
</p>
</a>
</div>
</div>
<div class="level is-mobile continue-reading">
<div class=level-left>
</div>
<div class=level-right>
<a href=/posts/typescript_tip-15/>続きを読む <i class="fa fa-angle-double-right" aria-hidden=true></i></a>
</div>
</div>
<hr>
</div><div class=blog-brief>
<a href=/posts/vue_ref_vs_reactive/>
<h3 class="title is-4">
Refとreactive
</h3>
</a>
<div class="level is-mobile details">
<div class=level-left>
<div class=level-item>
<a href=/posts/vue_ref_vs_reactive/>
<p class="subtitle info date">Mar 25, 2022
</p>
</a>
</div>
<div class=level-item>
<a href=/posts/vue_ref_vs_reactive/>
<p class="subtitle info">
4 mins read
</p>
</a>
</div>
</div>
<div class="level-right is-hidden-touch">
<a class="tag is-rounded" href=/tags/vue.js>Vue.js</a>
</div>
</div>
<div>
<div>
<a href=/posts/vue_ref_vs_reactive/>
<p class=summary>
背景 refとreactiveの使い分けがパッとでてこなかったことがあったのでまとめていく。
概要 どの状況で使い分ければいいのか refとreactiveの違い 本題 1.どの状況で使い分ければいいのか refはプリミティブ型に対して使用する。 reactiveはオブジェクト型に対して使用する。
2.refとreactiveの違い ref const boolean = ref(false) // export function ref&lt;boolean>(value: boolean): Ref&lt;boolean> TypeScriptの場合は、引数(初期値)を型推論してくれる。 明示的にしたい型注釈したい場合は、ref&lt;boolean | null>(false)と使用することもできる。 基本的になんでも(オブジェクト、配列、プリミティブ)refで使用ができる。 引数の値がオブジェクトの場合は、Vue内部でreactiveに更新している。更新している負荷を与えてしまうため、オブジェクトの場合は、reactiveを使用したほうがいいと言われている。 ref.valueでデータを格納する Ex)boolean.value = true reactive const user = reactive({ firstName: '太郎', lastName: '山田', height: 160, weight: 50 }) // const user: {firstName: string, lastName: string, height: number, weight: number} TypeScriptの場合は、引数(初期値)を型推論してくれる。 型注釈をつけたい場合は、ジェネクリスを使用できる const user = reactive&lt;{ firstName?: string lastName?
</p>
</a>
</div>
</div>
<div class="level is-mobile continue-reading">
<div class=level-left>
</div>
<div class=level-right>
<a href=/posts/vue_ref_vs_reactive/>続きを読む <i class="fa fa-angle-double-right" aria-hidden=true></i></a>
</div>
</div>
<hr>
</div><div class=blog-brief>
<a href=/posts/vue_watch-and-watcheffect/>
<h3 class="title is-4">
WatchとwatchEffect
</h3>
</a>
<div class="level is-mobile details">
<div class=level-left>
<div class=level-item>
<a href=/posts/vue_watch-and-watcheffect/>
<p class="subtitle info date">Mar 18, 2022
</p>
</a>
</div>
<div class=level-item>
<a href=/posts/vue_watch-and-watcheffect/>
<p class="subtitle info">
6 mins read
</p>
</a>
</div>
</div>
<div class="level-right is-hidden-touch">
<a class="tag is-rounded" href=/tags/vue.js>Vue.js</a>
</div>
</div>
<div>
<div>
<a href=/posts/vue_watch-and-watcheffect/>
<p class=summary>
背景 Vue.jsを使用する際にwatchを使う頻度はそこまで多くなく、使う度にドキュメントを確認するので、記事にまとめておく。
概要 Vue3のwatchとwatchEffectの仕様をまとめていく。また、それぞれの違いもまとめる。
本題 watch 説明 指定したデータを監視して、変化があればコールバック関数が実行する。
使い方 単一のデータ監視と複数のデータ監視の2種類の使い方が存在する。
1. 単一のデータを監視する場合 const count = ref(0) // 第一引数に監視したいデータを記載する watch(count, (newCount, prevCount) => { /* ... */ }) const state = reactive({ count: 0 }) // 第一引数に監視したいデータをコールバック関数で記載する watch(() => state.count, (newCount, prevCount) => { /* ... */ } ) 2. 複数のデータを監視する場合 配列を使用することで、複数のデータを監視できる 複数の監視データが同時に変更する時には、コールバック関数は一度して動かないため注意 const firstName = ref('') const lastName = ref('') // 第一引数を配列にしている watch([firstName, lastName], (newValues, prevValues) => { console.
</p>
</a>
</div>
</div>
<div class="level is-mobile continue-reading">
<div class=level-left>
</div>
<div class=level-right>
<a href=/posts/vue_watch-and-watcheffect/>続きを読む <i class="fa fa-angle-double-right" aria-hidden=true></i></a>
</div>
</div>
<hr>
</div>
<div class=content>
<a href=/posts/>
<h4 class="has-text-centered seeall">全てを見る</h4>
</a>
</div>
</div>
</div>
<footer class="footer has-background-dark">
<div class="content has-text-centered has-text-white">
<p>© 2022 issei1213 All rights reserved.</p>
</div>
</footer>
</body>
</html>