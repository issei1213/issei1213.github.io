<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on TechBlog</title><link>https://issei1213.github.io/posts/</link><description>Recent content in Posts on TechBlog</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 07 Apr 2022 12:43:39 +0900</lastBuildDate><atom:link href="https://issei1213.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Typescript Tip #1</title><link>https://issei1213.github.io/posts/typescript_tip-1/</link><pubDate>Thu, 07 Apr 2022 12:43:39 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-1/</guid><description>背景 前回のmattさんのTypeScript Tip #15が勉強になったので、最初から#1からまとめていく
概要 export const fruitCounts = { apple: 1, pear: 4, banana: 26 } 上記の様なコードがあった時に、特定のキーを取得する型エイリアスで定義すると以下になる。
type SingleFruitCount = | { apple: number } | { banana: number } | { pear: number } const singleFruitCount: SingleFruitCount = { apple: 10, } SingleFruitCountの型エイリアスを作成すれば、型定義できるが定数fruitCountsを型推論させて型エイリアスを作成する。
本題 最終的なコードは以下になる。具体的に解説していく。
type FruitCounts = typeof fruitCounts type NewSingleFruitCount = { [ K in keyof FruitCounts ]: { [K2 in K]: number } }[keyof FruitCounts] // type NewSingleFruitCount = { // apple: number; // } | { // pear: number; // } | { // banana: number; // } typeof fruitCountsは型推論が効いて以下の型が作成される。 type FruitCounts = { apple: number; pear: number; banana: number; } [ K in keyof FruitCounts ]のkeyof FruitCountsは型エイリアスのオブジェクトのキーのみを取得することができる。</description></item><item><title>りあクトのTypeScriptサンプルコードリーディング</title><link>https://issei1213.github.io/posts/typescript_react-sample-code-reading/</link><pubDate>Sat, 02 Apr 2022 13:39:20 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_react-sample-code-reading/</guid><description>背景 TypeScriptの教材で以下のサンプルコードがあったので、コードリーディングしていく。
概要 以下のコードリーディングをしていく。
非同期データ取得関数をラップして、そこで起きる例外をフォローしつつ正常系と異常系に振り分ける関数を定義している。
type Result&amp;lt;T, E extends Error&amp;gt; = Ok&amp;lt;T, E&amp;gt; | Err&amp;lt;T, E&amp;gt; export class Ok&amp;lt;T, E extends Error&amp;gt; { constructor(readonly val: T) {} isOk = (): this is Ok&amp;lt;T, E&amp;gt; =&amp;gt; true isErr = (): this is Err&amp;lt;T, E&amp;gt; =&amp;gt; false } export class Err&amp;lt;T, E extends Error&amp;gt; { constructor(readonly err: E) {} isOk = (): this is Ok&amp;lt;T, E&amp;gt; =&amp;gt; false isErr = (): this is Err&amp;lt;T, E&amp;gt; =&amp;gt; true } export const withResult = &amp;lt;T, A extends any[], E extends Error&amp;gt;(fn: (.</description></item><item><title>TypeScript Tip #15</title><link>https://issei1213.github.io/posts/typescript_tip-15/</link><pubDate>Fri, 01 Apr 2022 23:23:48 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-15/</guid><description>背景 Twitterを眺めていると汎用性が高そうな関数を作成できるTypeScriptのツイートがあったので、整理するためにまとめる。
https://twitter.com/mpocock1/status/1509850662795989005
概要 関数の引数のタイプをみて、タイプに応じてpayloadが必要か必要がないかをTypeScriptで判断する。
// 第一引数がSIGN_OUTの場合は、payloadはなし sendEvent(&amp;#39;SIGN_OUT&amp;#39;) // 第一引数がLOG_INの場合は、payloadは必須 sendEvent(&amp;#34;LOG_IN&amp;#34;, { userId: &amp;#39;123&amp;#39; }) 成功パターン
sendEvent(&amp;#39;SIGN_OUT&amp;#39;) sendEvent(&amp;#34;LOG_IN&amp;#34;, { userId: &amp;#39;123&amp;#39; }) 失敗パターン(コンパイルエラー)
sendEvent(&amp;#39;SIGN_OUT&amp;#39;, {}) sendEvent(&amp;#39;LOG_IN&amp;#39;, { userId: 122 }) sendEvent(&amp;#39;LOG_IN&amp;#39;, {}) sendEvent(&amp;#39;LOG_IN&amp;#39;) 本題 以下のコードで実現可能
type AuthEvent = | { type: &amp;#39;LOG_IN&amp;#39; payload: { userId: string } } | { type: &amp;#39;SIGN_OUT&amp;#39; } const sendEvent = &amp;lt;Type extends AuthEvent[&amp;#39;type&amp;#39;]&amp;gt;( ...args: Extract&amp;lt;AuthEvent, { type: Type }&amp;gt; extends { payload: infer TPayload } ?</description></item><item><title>refとreactive</title><link>https://issei1213.github.io/posts/vue_ref_vs_reactive/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0900</pubDate><guid>https://issei1213.github.io/posts/vue_ref_vs_reactive/</guid><description>背景 refとreactiveの使い分けがパッとでてこなかったことがあったのでまとめていく。
概要 どの状況で使い分ければいいのか refとreactiveの違い 本題 1.どの状況で使い分ければいいのか refはプリミティブ型に対して使用する。 reactiveはオブジェクト型に対して使用する。
2.refとreactiveの違い ref const boolean = ref(false) // export function ref&amp;lt;boolean&amp;gt;(value: boolean): Ref&amp;lt;boolean&amp;gt; TypeScriptの場合は、引数(初期値)を型推論してくれる。 明示的にしたい型注釈したい場合は、ref&amp;lt;boolean | null&amp;gt;(false)と使用することもできる。 基本的になんでも(オブジェクト、配列、プリミティブ)refで使用ができる。 引数の値がオブジェクトの場合は、Vue内部でreactiveに更新している。更新している負荷を与えてしまうため、オブジェクトの場合は、reactiveを使用したほうがいいと言われている。 ref.valueでデータを格納する Ex)boolean.value = true reactive const user = reactive({ firstName: &amp;#39;太郎&amp;#39;, lastName: &amp;#39;山田&amp;#39;, height: 160, weight: 50 }) // const user: {firstName: string, lastName: string, height: number, weight: number} TypeScriptの場合は、引数(初期値)を型推論してくれる。 型注釈をつけたい場合は、ジェネクリスを使用できる const user = reactive&amp;lt;{ firstName?: string lastName?</description></item><item><title>watchとwatchEffect</title><link>https://issei1213.github.io/posts/vue_watch-and-watcheffect/</link><pubDate>Fri, 18 Mar 2022 10:36:36 +0900</pubDate><guid>https://issei1213.github.io/posts/vue_watch-and-watcheffect/</guid><description>背景 Vue.jsを使用する際にwatchを使う頻度はそこまで多くなく、使う度にドキュメントを確認するので、記事にまとめておく。
概要 Vue3のwatchとwatchEffectの仕様をまとめていく。また、それぞれの違いもまとめる。
本題 watch 説明 指定したデータを監視して、変化があればコールバック関数が実行する。
使い方 単一のデータ監視と複数のデータ監視の2種類の使い方が存在する。
1. 単一のデータを監視する場合 const count = ref(0) // 第一引数に監視したいデータを記載する watch(count, (newCount, prevCount) =&amp;gt; { /* ... */ }) const state = reactive({ count: 0 }) // 第一引数に監視したいデータをコールバック関数で記載する watch(() =&amp;gt; state.count, (newCount, prevCount) =&amp;gt; { /* ... */ } ) 2. 複数のデータを監視する場合 配列を使用することで、複数のデータを監視できる 複数の監視データが同時に変更する時には、コールバック関数は一度して動かないため注意 const firstName = ref(&amp;#39;&amp;#39;) const lastName = ref(&amp;#39;&amp;#39;) // 第一引数を配列にしている watch([firstName, lastName], (newValues, prevValues) =&amp;gt; { console.</description></item></channel></rss>