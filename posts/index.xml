<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on TechBlog</title><link>https://issei1213.github.io/posts/</link><description>Recent content in Posts on TechBlog</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 31 Jul 2024 01:18:06 +0900</lastBuildDate><atom:link href="https://issei1213.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Compound Patternについて</title><link>https://issei1213.github.io/posts/compound-pattern/</link><pubDate>Wed, 31 Jul 2024 01:18:06 +0900</pubDate><guid>https://issei1213.github.io/posts/compound-pattern/</guid><description>背景 宮崎のReact勉強会で小規模なLTをしたので、発表した内容をまとめる。
LTではCompound Pattern（複合パターン）について発表を行った。
概要 Compound Pattern（複合パターン）とは、コンポーネント設計パターンの一つ 複数のコンポーネントを組み合わせて、複雑なコンポーネントを構築する方法 ユースケース お知らせ機能をModalコンポーネントを使って実装している 実際に使用しているコンポーネントは以下
modal.tsx
const Modal: React.FC&amp;lt;ModalProps&amp;gt; = ({onClose, children }) =&amp;gt; { return ( &amp;lt;div className=&amp;#34;...&amp;#34; onClick={onClose}&amp;gt; &amp;lt;dialog open className=&amp;#34;...&amp;#34; onClick={(e) =&amp;gt; e.stopPropagation()} &amp;gt; {/* NOTE: モーダル閉じるボタン */} &amp;lt;button className=&amp;#34;...&amp;#34; onClick={onClose} &amp;gt; &amp;lt;Icon variant=&amp;#34;close&amp;#34; className=&amp;#34;...&amp;#34; /&amp;gt; &amp;lt;/button&amp;gt; {/* NOTE: ヘッダー・テキスト・フッターなどはchildrenで表示 */} {children} &amp;lt;/dialog&amp;gt; &amp;lt;/div&amp;gt; ); }; modal.tsx を使った実装コード
const ModalPage = () =&amp;gt; { return ( &amp;lt;Modal&amp;gt; &amp;lt;Heading as=&amp;#34;h2&amp;#34;&amp;gt;システムメンテナンスのお知らせ&amp;lt;/Heading&amp;gt; &amp;lt;div className=&amp;#34;.</description></item><item><title>社内輪読会</title><link>https://issei1213.github.io/posts/reading-group-1/</link><pubDate>Sun, 30 Jun 2024 01:36:29 +0900</pubDate><guid>https://issei1213.github.io/posts/reading-group-1/</guid><description>背景 最近の社内で輪読会でリーダブルコードを読む機会があった。
その際に、自分が改めて気づきがあったので、それをまとめる。
概要 輪読会では第2章と第3章を読んだため、それぞれの内容をまとめる。
本題 第2章: 名前に情報を詰め込む スコープが小さければ短い名前でもいい スコープの小さい関数で使われる変数などで、見える範囲が狭い場合は、短い名前でも問題ない。 全ての情報がみえるのので、短くていい
if(debug) { const m = Map() lookUpNAmesNumbers(m) console.log(m) } 上記の例では、mという変数名は短いが、スコープが小さいため問題ない。
例えば、mがグローバル変数だとすると、mという変数名だけでは何をしているのかわからない。その場合は、別の命名を検討する。
頭文字と省略文字 エンジニアは文字を省略して書く癖がある。例えば、BackEndManagerをBEManagerと省略することがある。
しかし、これは避けるべきである。新しい人がコードを読む際に、何を指しているのかわからないため。理解できるなら問題ない。
問題ない例として、documentをdoc、stringをstrと省略することは問題ない。 ここの線引きは難しいが、理解できる範囲で省略することが大事。
第3章: 誤解されない名前 範囲を指定するときはfirstとlastを使う 範囲を指定するときは、firstとlastを使うことで、範囲を指定することができる。
例えば、以下の様なコードがあったする。
function intgerRange(start = 2, stop = 4){ ... } 上記の関数は、startの2から始まることはわかるが、stopの4を含むのか含まないのかわからない。 そのため、firstとlastを使うことで、範囲を指定することができる。
function intgerRange(first = 2, last = 4){ ... } 上記の関数は、startの2から始まり、stopの4を含むことがわかる。
ブール値の名前 ブール値の命名を否定系にすることは避けるべきである。
例えば以下のコードは、否定系の命名になっている。
const disableSsl = false 上記のコードは、disableSslがfalseの場合、SSLが有効になることがわかるが、trueの場合はSSLが無効になることがわかる。 これでは、コードの可読性が下がるため、肯定系の命名をすることが望ましい。
const enableSsl = true 上記のコードは、enableSslがtrueの場合、SSLが有効になることがわかり、可読性が上がる。</description></item><item><title>TypeScriptで網羅性チェック</title><link>https://issei1213.github.io/posts/typescript-exhaustive-check/</link><pubDate>Fri, 31 May 2024 00:27:26 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript-exhaustive-check/</guid><description>背景 ソフトウェアデザインを読んでいて網羅性チェックについて知ったので、TypeScriptでの網羅性チェックについて自分なりにまとめてみた。
概要 網羅性チェックとは、全てのケースを網羅しているどうかをチェックしていることを指す。
TypeScriptは様々なケースで利用できるが、今回は文字列リテラル型を利用して網羅性チェックを行う方法をまとめていく。
本題 以下のようなコードがあるとする。
Fruit型にはapple、banana、orangeの3つの文字列リテラル型があり、checkAllFruits関数はFruit型を引数に取り、その値によって処理を分岐している。
ここではシンプルにconsole.logで出力している。
type Fruit = &amp;#39;apple&amp;#39; | &amp;#39;banana&amp;#39; | &amp;#39;orange&amp;#39;; function checkAllFruits(fruit: Fruit): void { if(fruit === &amp;#39;apple&amp;#39;) { console.log(&amp;#39;This is an apple.&amp;#39;); return } else if (fruit === &amp;#39;banana&amp;#39;) { console.log(&amp;#39;This is a banana.&amp;#39;); return } else { console.log(&amp;#39;This is an orange.&amp;#39;); return } } checkAllFruits(&amp;#39;apple&amp;#39;) // This is an apple. checkAllFruits(&amp;#39;banana&amp;#39;) // This is an banana. checkAllFruits(&amp;#39;orange&amp;#39;) // This is an orange.</description></item><item><title>PMの見積もり手法</title><link>https://issei1213.github.io/posts/pm-estimate/</link><pubDate>Tue, 30 Apr 2024 23:00:03 +0900</pubDate><guid>https://issei1213.github.io/posts/pm-estimate/</guid><description>背景 直近でPMの見積もりを行う機会があったので、その際に参考にした資料をまとめる。
概要 こちらの参考書をもとに見積もりの方法をまとめる
本題 見積もりは工数を前提で作成していく。 工数が精度が荒い「概算見積もり」と、精度の高い「詳細見積もり」を段階的に提示していく必要がある。
概算見積もり：精度が荒いが、短時間で作成できる 詳細見積もり：精度が高いが、時間がかかる 概算見積もり 不確実性が多い段階で提出する見積もりのこと。 この見積もりを作成する時には、以下の内容を明記しておくことが重要。
「これは現時点での概算見積もりです。詳細見積もりは設計完了後に改めて行います」と日付と合わせて明記する 外部システムに影響する可能性がある場合、「外部システム連携の内容によって変動する可能性あり」と明記する また、概算見積もりを作成する時には、バッファを見込んで作成する。追加予算が発生した時に、調整が大変になる可能性がある。
詳細見積もり 不確実性をかなり潰した状態(要件定義や設計が完了した状態)で提示する見積もり
Ex）ECサイトの場合、画面数や機能の詳細が明確になっている状態
正しい見積もり方の手順 見積もりの一番失敗しやすいパターンは、定例会議なので口頭のみでざっくりと見積もりを提示すること。 かならず持ち帰って見積もりを実施すること大事。
今回かの正しい手順に関しては、ボトムアップ見積もりをベースにしている。
ボトムアップ見積もり
成果物や作業を分割してそれぞれの構成要素の工数を算出して、積み上げて全体の工数を見積もる方法。
手順1: やることを細分化して積み上げ式で見積もり 誰が何をするかを明確にし、メンバーのタスクレベルを落とし込む。 以下のルールを則り、見積もり表を作成していく
工数は各領域の専門家に入力していく。PMが作成する場合でも、最終的に専門家に確認してもらうことが重要。 工数は1, 3, 5, 10, 15 &amp;hellip;を5人日以上の工数は5人日単位で見積もる これは実際のタスクを遂行していくと、予想外の作業が発生することがあるため、バッファを積むことを目的としている。 プロジェクトマネージャーやディレクターのマネジメント工数やテスト工数などは漏れて赤字になる可能性があるため、見積もりの際には必ず入力すること。 項目 工数 費用 1 トップ画面　 5 250,000 2 ログイン画面 3 150,000 3 マイページ画面 5 250,000 4 記事画面 10 500,000 5 インフラ構築 15 750,000 6 データベース設計 15 750,000 &amp;hellip; &amp;hellip; &amp;hellip; &amp;hellip; 28 マネジメント工数 30 1,500,000 29 テスト工数 15 750,000 工数が入力すると、その人の１日あたりの単価をかけると、費用が算出できる。 こうすることで、提示された側からみても「明朗会計」になり、信頼しやすくなる。</description></item><item><title>Jestのリーダブルテストコード</title><link>https://issei1213.github.io/posts/readable-testing-code/</link><pubDate>Mon, 29 May 2023 02:00:03 +0900</pubDate><guid>https://issei1213.github.io/posts/readable-testing-code/</guid><description>背景 今週、社内のメンバーから以下のリーダブルテストコードの記事を見せてもらった。 かなり自分の中でささったので、Jestの場合どうするかを考えてみた
リーダブルテストコード
過度なDRYを行わず、APIドキュメントだと思って書く 脳内メモリを消費させない“リーダブルなテストコード”の書き方
概要 上記の参考記事を参考に、Jest(React)の場合、どのようにリーダブルテストコードを書くかを考えてみた。 今回は、UIコンポーネントとカスタムHookそれぞれのテストコードを書いていく。
本題 参考の記事にはリーダブルテストコードを書くには、以下の様に書く必要がある記載している
テストコードにおいて、過度なDRYは読みやすさの敵 賢くてロジカルなテストコードより、誰でも(非エンジニアでも)読める愚直なテストコードを 脳内メモリを使わないテストコードはリーダブル 変数をなくし、上から順番に見るだけでテストの意図がわかるようにする 実行可能なAPIドキュメントだと思ってテストコードを書こう(テストコードはプログラムじゃなくてドキュメント) もっとリーダブルにするコツ
実際のユースケースに近いテストデータを使用する 「あああ」「テストテスト」「ユーザー１」みたいなテストデータはNG describe / context / itの説明を丁寧に書く 「it &amp;ldquo;適切な値を返す&amp;rdquo;」みたいな具体性のない説明はNG すべての情報が1画面に収まるテストコードが理想 上下スクロールが頻繁に発生したり、他のファイルが見に行かなきゃいけないのはNG DRY禁止はあくまで原則。適宜メリット・デメリットを天秤にかける。 「明確なメリットがあるDRY」や「可読性の損なわない抽象化」まで放棄するのはNG 上記を考慮して、React(Jest)のテストケースを書いていく
UIコンポーネントテスト テスト対象コンポーネント inputタグで入力した値firstNameとlastNameが、pタグで表示されるようになっている。
// @ref: https://react.dev/learn/reusing-logic-with-custom-hooks#custom-hooks-let-you-share-stateful-logic-not-state-itself import { useFormInput } from &amp;#39;./useFormInput&amp;#39;; export const Form = () =&amp;gt; { const firstNameProps = useFormInput(&amp;#39;&amp;#39;); const lastNameProps = useFormInput(&amp;#39;&amp;#39;); return ( &amp;lt;&amp;gt; &amp;lt;label&amp;gt; First name: &amp;lt;input type=&amp;#39;text&amp;#39; name=&amp;#39;firstName&amp;#39; {.</description></item><item><title>Testing Libraryで暗黙的なロールを使用したDOMの取得方法</title><link>https://issei1213.github.io/posts/testing-library_getbyrole/</link><pubDate>Sun, 21 May 2023 23:11:10 +0900</pubDate><guid>https://issei1213.github.io/posts/testing-library_getbyrole/</guid><description>背景 現在以下の書籍でフロントのテストを学習しているので、勉強になったDOMの取得方法をまとめる。 書籍通り、ReactのUIコンポーネントのテスト方法を記載していく。
概要 ReactのUIコンポーネントのDOMを取得する方法で、暗黙的なロールを活用した取得方法があったので、まとめていく
本題 以下のコンポーネントのテストをしていく。
import {ReactNode} from &amp;#34;react&amp;#34;; export const Heading = ({children}: {children: ReactNode}) =&amp;gt; { return ( &amp;lt;h1&amp;gt;{children}&amp;lt;/h1&amp;gt; ); }; 今回は簡易的に、propsの値がh1タグで表示されているかをテストしていく。
import {render, screen} from &amp;#34;@testing-library/react&amp;#34;; import {Heading} from &amp;#34;./Heading&amp;#34;; test(&amp;#39;propsが値がh1タグに存在していること&amp;#39;, () =&amp;gt; { render(&amp;lt;Heading&amp;gt;test&amp;lt;/Heading&amp;gt;) expect(screen.getByRole(&amp;#39;heading&amp;#39;, {name: &amp;#39;test&amp;#39;})).toBeInTheDocument() }) 上記のgetByRoleの第一引数にheadingを指定しているが、h1タグの暗黙的なロールがheadingであるため、headingを指定している。
このように暗黙的なロールをうまく使えば、test-idみたいなカスタム属性をなどを使用せずに、テストをかくことができる。 また、Testing Libraryも公式も暗黙的なロールを使用することを推奨している。
暗黙的なルール一覧はこちらから確認ができる。
※上記はaria-queryというライブラリのドキュメントであるが、Testing Libraryのライブラリは内部的に依存するので、上記を参考にしても問題ない
まとめ UIコンポーネントのテストをする際は、暗黙的なロールを使用することで、テストを書きやすくなるので、ぜひ活用していきたい。
参考文献 Testing Library
暗黙的なルール一覧(aria-query)
フロントエンド開発のためのテスト入門 今からでも知っておきたい自動テスト戦略の必須知識</description></item><item><title>関数命名について getXXX と createXXX の違い</title><link>https://issei1213.github.io/posts/which_use_getxxx_or_createxxx/</link><pubDate>Sun, 14 May 2023 23:45:27 +0900</pubDate><guid>https://issei1213.github.io/posts/which_use_getxxx_or_createxxx/</guid><description>背景 現在の参画している案件で「週1ゆるアウトプット」という名前でアウトプットしている方がいたので、自分も真似してみようと思う。
今回は、コードを書いていてふと気になったことがあったので、簡単にまとめていく。
概要 戻り地がある関数を命名するときに、createXXXとgetXXXのどちらを使うか迷ったので、まとめていく。
本題 以下はサンプルコードを記載する。 名前のフルネームを作成する関数である。
createFullNameとgetFullNameのどちらが適切かをまとめていく。
// 1. createXXX const createFullName = (firstName: string, lastName: string): string =&amp;gt; { return `${firstName}${lastName}` } // 2. getXXX const getFullName = (firstName: string, lastName: string): string =&amp;gt; { return `${firstName}${lastName}` } ポイントとしては、getXXXは通常、既存のデータやリソースを取得するときに使用することを想定すること。
createXXXは新しいデータを作成するときに使用する。
なので、今回の場合は、既存のデータやリソースを取得するわけではないので、createXXXを使用するのが適切だと判断。
getXXXを使ったサンプルは以下
ユーザー情報を取得する場合 const getUserInfo = (userId: string) =&amp;gt; { // ユーザー情報を取得するロジック }; 配列から特定の要素を取得する場合 const getElementAtIndex = (array: string[], index: number) =&amp;gt; { return array[index]; }; オブジェクトのプロパティ値を取得する関数 const getPropertyValue = (object: Object, propertyName: string) =&amp;gt; { return object[propertyName]; }; まとめ 今回は、関数の命名についてcreateXXXとgetXXXのどちらを使うか迷ったので、まとめてみた。 getXXXは通常、既存のデータやリソースを取得するときに使用することを想定すること。</description></item><item><title>Component TypesとEvent Handlers</title><link>https://issei1213.github.io/posts/solidjs_types/</link><pubDate>Fri, 12 Aug 2022 21:08:23 +0900</pubDate><guid>https://issei1213.github.io/posts/solidjs_types/</guid><description>背景 SolidJSのコンポーネントとイベントハンドラの型定義について悩んでいたが、公式で解説が乗っていたので、
個人的にまとめることにする。
概要 コンポーネントとイベントハンドラの型定義の方法をまとめていく。
公式ではコンポーネントの型をComponent Types、エベントハンドラの型をEvent Handlersとして記載しているので、 同一の単語を使用していく。
本題 Component Types Component import type { JSX, Component } from &amp;#39;solid-js&amp;#39;; type Component&amp;lt;P = {}&amp;gt; = (props: P) =&amp;gt; JSX.Element; 基本的にはReactのFCと同じような使い型ができ、propsの型をジェネリクスで定義することができる。
戻り値はJSX.Elementになる。
サンプルコード　※公式のコードを参照
import { render } from &amp;#34;solid-js/web&amp;#34;; import { createSignal, Component } from &amp;#34;solid-js&amp;#34;; const Counter: Component = () =&amp;gt; { const [count, setCount] = createSignal(0); return ( &amp;lt;button onClick={() =&amp;gt; setCount((c) =&amp;gt; c+1)}&amp;gt; {count()} &amp;lt;/button&amp;gt; ); }; const InitCounter: Component&amp;lt;{initial: number}&amp;gt; = (props) =&amp;gt; { const [count, setCount] = createSignal(props.</description></item><item><title>TypeScript Tip #20</title><link>https://issei1213.github.io/posts/typescript_tip-20/</link><pubDate>Wed, 20 Apr 2022 23:30:11 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-20/</guid><description>背景 今回もmattさんのTypeScriptTipsを解説していく。
TypeScript Tip #20
概要 以下のオブジェクトの型が存在している時に、特定のキーのバリューのユニオンを作成する時に使用する。
export type Obj = { a: &amp;#39;a&amp;#39;, a2: &amp;#39;a2&amp;#39;, a3: &amp;#39;a3&amp;#39;, b: &amp;#39;b&amp;#39;, b1: &amp;#39;b1&amp;#39;, b2: &amp;#39;b2&amp;#39; } // 上記の型から以下の型を作成したい type NewUnion = &amp;#34;a&amp;#34; | &amp;#34;a2&amp;#34; | &amp;#34;a3&amp;#34; 本題 以下が実際の型定義になる。順番に解説していく。
type ValuesOfKeysStartingWithA&amp;lt;Obj&amp;gt; = { [K in Extract&amp;lt;keyof Obj, `a${string}`&amp;gt;]: Obj[K]; }[Extract&amp;lt;keyof Obj, `a${string}`&amp;gt;] type NewUnion = ValuesOfKeysStartingWithA&amp;lt;Obj&amp;gt; // type NewUnion = &amp;#34;a&amp;#34; | &amp;#34;a2&amp;#34; | &amp;#34;a3&amp;#34; 今回のポイントはExtract&amp;lt;keyof Obj,`a${string}`&amp;gt;になるため細かくみていく。 まず、a${string}がどのように型定義されるかというと、文字列aを含めて文字列リテラル型を定義できる。 type TestType = `a${string}` // Success const test1: TestType = &amp;#39;a&amp;#39; const test2: TestType = &amp;#39;a1&amp;#39; // Error const test3: TestType = &amp;#39;1&amp;#39; // Type &amp;#39;&amp;#34;1&amp;#34;&amp;#39; is not assignable to type &amp;#39;`a${string}`&amp;#39;.</description></item><item><title>TypeScript Tip #8</title><link>https://issei1213.github.io/posts/typescript_tip-8/</link><pubDate>Fri, 15 Apr 2022 00:14:16 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-8/</guid><description>背景 今回もmattさんのTypeScriptTipsをまとめていく。
TypeScript Tip #8
概要 Reactのジェネリクスを使用して、動的で柔軟なコンポーネントを作成することができる。
本題 以下のコードはReactのサンプルのコードである。
Tableコンポーネントのpropsに存在するitemsはオブジェクトの配列になっている。
オブジェクトはプロパティidのみを保持している。
import React from &amp;#39;react&amp;#39; interface TableProps { items: { id: string }[] renderItem: (item: { id: string }) =&amp;gt; React.ReactNode } export const Table = (props: TableProps) =&amp;gt; { return null } const Component = () =&amp;gt; { return ( &amp;lt;Table items={[ { id: &amp;#39;1&amp;#39;, } ]} renderItem={(item) =&amp;gt; &amp;lt;div&amp;gt;{ item.id }&amp;lt;/div&amp;gt;} &amp;gt;&amp;lt;/Table&amp;gt; ) } 上記の場合、propsitemsにオブジェクトのid以外のプロパティを定義したい場合、TablePropsにも追加をしてやる必要がある。 以下はそのサンプルコード</description></item><item><title>TypeScript Tip #7</title><link>https://issei1213.github.io/posts/typescript_tip-7/</link><pubDate>Wed, 13 Apr 2022 23:11:35 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-7/</guid><description>背景 今回もmattさんの記事をまとめていく。
TypeScript Tip #7
概要 オブジェクト中身を順番に処理していく時には、以下のコードを用いることがある。
const myObject = { a: 1, b: 2, c: 3 } Object.keys(myObject).forEach((key) =&amp;gt; { console.log(myObject[key]) // Element implicitly has an &amp;#39;any&amp;#39; type because expression of type &amp;#39;string&amp;#39; can&amp;#39;t be used to index type &amp;#39;{ a: number; b: number; c: number; }&amp;#39;. // No index signature with a parameter of type &amp;#39;string&amp;#39; was found on type &amp;#39;{ a: number; b: number; c: number; }&amp;#39;.</description></item><item><title>TypeScript Tip #5</title><link>https://issei1213.github.io/posts/typescript_tip-5/</link><pubDate>Sun, 10 Apr 2022 12:43:14 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-5/</guid><description>背景 今回もmattさんの動画をまとめていく
TypeScript Tip #5
概要 型推論された型に対してextendsを使用するまとめていく。
本題 実際のサンプルコードは以下。 getDeepValue関数の引数にオブジェクトを渡して、そこから型推論をさせている。
第2引数、第3引数のオブジェクトのキーを指定して、最終的なバリューを取得できるような関数を作成する。
export const getDeepValue = &amp;lt; Obj, FirstKey extends keyof Obj, SecondKey extends keyof Obj[FirstKey] &amp;gt;( obj: Obj, firstKey: FirstKey, secondKey: SecondKey ): Obj[FirstKey][SecondKey] =&amp;gt; { return obj[firstKey][secondKey] } const obj = { foo: { a: true, b: 2 }, bar: { c: &amp;#39;cool&amp;#39;, d: 2 } } console.log(getDeepValue(obj, &amp;#39;bar&amp;#39;, &amp;#39;d&amp;#39;)) 引数の第2引数FirstKeyは型推論されたObjに制約を設けている。 FirstKey extends keyof { foo: { a: boolean; b: number; }; bar: { c: string; d: number; }; } 🔽 FirstKey extends &amp;#34;foo&amp;#34; | &amp;#34;bar&amp;#34; よって、FirstKeyはfooかbarのどちらかになる。</description></item><item><title>TypeScript Tip #3</title><link>https://issei1213.github.io/posts/typescript_tip-3/</link><pubDate>Sat, 09 Apr 2022 01:13:25 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-3/</guid><description>背景 今回もmattoさんのコードリーディングをしていく。
TypeScript Tip #3
概要 今回はTypeScriptのユーティリティをまとめたライブラリts-toolbeltについて説明していく。
注意点としては、TypeScriptバージョンが4.1以上である必要がある。 数多くのユーティリティが提供されているため、今回はMattさんの解説に絞ってまとめていく。
ts-toolbelt
本題 使い方 ライブラリの中から使用したいユーティリティをimportして使用する。
import { String, Union } from &amp;#39;ts-toolbelt&amp;#39;; 今回はURLの操作をする時に便利なユーティリティをまとめていく。
サンプルコード import { String, Union } from &amp;#39;ts-toolbelt&amp;#39;; const query = &amp;#39;/home?a=foo&amp;amp;b=wow&amp;#39; type Query = typeof query // type Query = &amp;#34;/home?a=foo&amp;amp;b=wow&amp;#34; type SecondQueryPart = String.Split&amp;lt;Query, &amp;#39;?&amp;#39;&amp;gt;[1] // type SecondQueryPart = &amp;#34;a=foo&amp;amp;b=wow&amp;#34; type QueryElements = String.Split&amp;lt;SecondQueryPart, &amp;#39;&amp;amp;&amp;#39;&amp;gt; // type QueryElements = [&amp;#34;a=foo&amp;#34;, &amp;#34;b=wow&amp;#34;] type QueryParams = { [ QueryElement in QueryElements[number] ]: { [ key in String.</description></item><item><title>TypeScript Tip #2</title><link>https://issei1213.github.io/posts/typescript_tip-2/</link><pubDate>Fri, 08 Apr 2022 20:26:20 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-2/</guid><description>背景 今回もmattoさんのTypeScriptの動画をまとめていく
概要 下記の様なEntityの型を定義する。
type Entity = | { type: &amp;#39;user&amp;#39; } | { type: &amp;#39;post&amp;#39; } | { type: &amp;#39;comment&amp;#39; } 上記の型の各オブジェクトにidを追加したい。その時のコードは以下になる。
typeに応じたidのプロパティを追加している。
type EntityWithId = | { type: &amp;#39;user&amp;#39; userId: string } | { type: &amp;#39;post&amp;#39; postId: string } | { type: &amp;#39;comment&amp;#39; commentId: string } const result1: EntityWithId = { type: &amp;#39;post&amp;#39;, postId: &amp;#39;123&amp;#39; } const result2: EntityWithId = { type: &amp;#39;user&amp;#39;, userId: &amp;#39;123&amp;#39; } 今回はEntityWithIdの部分をインデックスシグネチャを利用して作成していく。
本題 実際のコードは以下になる。細かくみていく。</description></item><item><title>TypeScript Tip #1</title><link>https://issei1213.github.io/posts/typescript_tip-1/</link><pubDate>Thu, 07 Apr 2022 12:43:39 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-1/</guid><description>背景 前回のmattさんのTypeScript Tip #15が勉強になったので、最初から#1からまとめていく
概要 export const fruitCounts = { apple: 1, pear: 4, banana: 26 } 上記の様なコードがあった時に、特定のキーを取得する型エイリアスで定義すると以下になる。
type SingleFruitCount = | { apple: number } | { banana: number } | { pear: number } const singleFruitCount: SingleFruitCount = { apple: 10, } SingleFruitCountの型エイリアスを作成すれば、型定義できるが定数fruitCountsを型推論させて型エイリアスを作成する。
本題 最終的なコードは以下になる。具体的に解説していく。
type FruitCounts = typeof fruitCounts type NewSingleFruitCount = { [ K in keyof FruitCounts ]: { [ K2 in K ]: number } }[keyof FruitCounts] // type NewSingleFruitCount = { // apple: number; // } | { // pear: number; // } | { // banana: number; // } typeof fruitCountsは型推論が効いて以下の型が作成される。 type FruitCounts = { apple: number; pear: number; banana: number; } [ K in keyof FruitCounts ]のkeyof FruitCountsは型エイリアスのオブジェクトのキーのみを取得することができる。</description></item><item><title>りあクトのTypeScriptサンプルコードリーディング</title><link>https://issei1213.github.io/posts/typescript_react-sample-code-reading/</link><pubDate>Sat, 02 Apr 2022 13:39:20 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_react-sample-code-reading/</guid><description>背景 TypeScriptの教材で以下のサンプルコードがあったので、コードリーディングしていく。
概要 以下のコードリーディングをしていく。
非同期データ取得関数をラップして、そこで起きる例外をフォローしつつ正常系と異常系に振り分ける関数を定義している。
type Result&amp;lt;T, E extends Error&amp;gt; = Ok&amp;lt;T, E&amp;gt; | Err&amp;lt;T, E&amp;gt; export class Ok&amp;lt;T, E extends Error&amp;gt; { constructor(readonly val: T) {} isOk = (): this is Ok&amp;lt;T, E&amp;gt; =&amp;gt; true isErr = (): this is Err&amp;lt;T, E&amp;gt; =&amp;gt; false } export class Err&amp;lt;T, E extends Error&amp;gt; { constructor(readonly err: E) {} isOk = (): this is Ok&amp;lt;T, E&amp;gt; =&amp;gt; false isErr = (): this is Err&amp;lt;T, E&amp;gt; =&amp;gt; true } export const withResult = &amp;lt;T, A extends any[], E extends Error&amp;gt;(fn: (.</description></item><item><title>TypeScript Tip #15</title><link>https://issei1213.github.io/posts/typescript_tip-15/</link><pubDate>Fri, 01 Apr 2022 23:23:48 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-15/</guid><description>背景 Twitterを眺めていると汎用性が高そうな関数を作成できるTypeScriptのツイートがあったので、整理するためにまとめる。
TypeScript Tip #15 概要 関数の引数のタイプをみて、タイプに応じてpayloadが必要か必要がないかをTypeScriptで判断する。
// 第一引数がSIGN_OUTの場合は、payloadはなし sendEvent(&amp;#39;SIGN_OUT&amp;#39;) // 第一引数がLOG_INの場合は、payloadは必須 sendEvent(&amp;#34;LOG_IN&amp;#34;, { userId: &amp;#39;123&amp;#39; }) 成功パターン
sendEvent(&amp;#39;SIGN_OUT&amp;#39;) sendEvent(&amp;#34;LOG_IN&amp;#34;, { userId: &amp;#39;123&amp;#39; }) 失敗パターン(コンパイルエラー)
sendEvent(&amp;#39;SIGN_OUT&amp;#39;, {}) sendEvent(&amp;#39;LOG_IN&amp;#39;, { userId: 122 }) sendEvent(&amp;#39;LOG_IN&amp;#39;, {}) sendEvent(&amp;#39;LOG_IN&amp;#39;) 本題 以下のコードで実現可能
type AuthEvent = | { type: &amp;#39;LOG_IN&amp;#39; payload: { userId: string } } | { type: &amp;#39;SIGN_OUT&amp;#39; } const sendEvent = &amp;lt;Type extends AuthEvent[&amp;#39;type&amp;#39;]&amp;gt;( ...args: Extract&amp;lt;AuthEvent, { type: Type }&amp;gt; extends { payload: infer TPayload } ?</description></item><item><title>refとreactive</title><link>https://issei1213.github.io/posts/vue_ref_vs_reactive/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0900</pubDate><guid>https://issei1213.github.io/posts/vue_ref_vs_reactive/</guid><description>背景 refとreactiveの使い分けがパッとでてこなかったことがあったのでまとめていく。
概要 どの状況で使い分ければいいのか refとreactiveの違い 本題 1.どの状況で使い分ければいいのか refはプリミティブ型に対して使用する。 reactiveはオブジェクト型に対して使用する。
2.refとreactiveの違い ref const boolean = ref(false) // export function ref&amp;lt;boolean&amp;gt;(value: boolean): Ref&amp;lt;boolean&amp;gt; TypeScriptの場合は、引数(初期値)を型推論してくれる。 明示的にしたい型注釈したい場合は、ref&amp;lt;boolean | null&amp;gt;(false)と使用することもできる。 基本的になんでも(オブジェクト、配列、プリミティブ)refで使用ができる。 引数の値がオブジェクトの場合は、Vue内部でreactiveに更新している。更新している負荷を与えてしまうため、オブジェクトの場合は、reactiveを使用したほうがいいと言われている。 ref.valueでデータを格納する Ex)boolean.value = true reactive const user = reactive({ firstName: &amp;#39;太郎&amp;#39;, lastName: &amp;#39;山田&amp;#39;, height: 160, weight: 50 }) // const user: {firstName: string, lastName: string, height: number, weight: number} TypeScriptの場合は、引数(初期値)を型推論してくれる。 型注釈をつけたい場合は、ジェネクリスを使用できる const user = reactive&amp;lt;{ firstName?: string lastName?</description></item><item><title>watchとwatchEffect</title><link>https://issei1213.github.io/posts/vue_watch-and-watcheffect/</link><pubDate>Fri, 18 Mar 2022 10:36:36 +0900</pubDate><guid>https://issei1213.github.io/posts/vue_watch-and-watcheffect/</guid><description>背景 Vue.jsを使用する際にwatchを使う頻度はそこまで多くなく、使う度にドキュメントを確認するので、記事にまとめておく。
概要 Vue3のwatchとwatchEffectの仕様をまとめていく。また、それぞれの違いもまとめる。
本題 watch 説明 指定したデータを監視して、変化があればコールバック関数が実行する。
使い方 単一のデータ監視と複数のデータ監視の2種類の使い方が存在する。
1. 単一のデータを監視する場合 const count = ref(0) // 第一引数に監視したいデータを記載する watch(count, (newCount, prevCount) =&amp;gt; { /* ... */ }) const state = reactive({ count: 0 }) // 第一引数に監視したいデータをコールバック関数で記載する watch(() =&amp;gt; state.count, (newCount, prevCount) =&amp;gt; { /* ... */ } ) 2. 複数のデータを監視する場合 配列を使用することで、複数のデータを監視できる 複数の監視データが同時に変更する時には、コールバック関数は一度して動かないため注意 const firstName = ref(&amp;#39;&amp;#39;) const lastName = ref(&amp;#39;&amp;#39;) // 第一引数を配列にしている watch([firstName, lastName], (newValues, prevValues) =&amp;gt; { console.</description></item></channel></rss>