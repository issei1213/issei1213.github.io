<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TypeScript on TechBlog</title><link>https://issei1213.github.io/tags/typescript/</link><description>Recent content in TypeScript on TechBlog</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 31 May 2024 00:27:26 +0900</lastBuildDate><atom:link href="https://issei1213.github.io/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>Typescript Exhaustive Check</title><link>https://issei1213.github.io/posts/typescript-exhaustive-check/</link><pubDate>Fri, 31 May 2024 00:27:26 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript-exhaustive-check/</guid><description>背景 ソフトウェアデザインを読んでいて網羅性チェックについて知ったので、TypeScriptでの網羅性チェックについて自分なりにまとめてみた。
概要 網羅性チェックとは、全てのケースを網羅しているどうかをチェックしていることを指す。 TypeScriptは様々なケースで利用できるが、今回は文字列リテラル型を利用して網羅性チェックを行う方法をまとめていく。
本題 以下のようなコードがあるとする。 Fruit型にはapple、banana、orangeの3つの文字列リテラル型があり、checkAllFruitHandler関数はFruit型を引数に取り、その値によって処理を分岐している。 ここではシンプルにconsole.logで出力している。
type Fruit = &amp;#39;apple&amp;#39; | &amp;#39;banana&amp;#39; | &amp;#39;orange&amp;#39;; function checkAllFruitHandler(fruit: Fruit): void { if(fruit === &amp;#39;apple&amp;#39;) { console.log(&amp;#39;This is an apple.&amp;#39;); return } else if (fruit === &amp;#39;banana&amp;#39;) { console.log(&amp;#39;This is a banana.&amp;#39;); return } else { console.log(&amp;#39;This is an orange.&amp;#39;); return } } checkAllFruitHandler(&amp;#39;apple&amp;#39;) // This is an apple. checkAllFruitHandler(&amp;#39;banana&amp;#39;) // This is an banana. checkAllFruitHandler(&amp;#39;orange&amp;#39;) // This is an orange.</description></item><item><title>Component TypesとEvent Handlers</title><link>https://issei1213.github.io/posts/solidjs_types/</link><pubDate>Fri, 12 Aug 2022 21:08:23 +0900</pubDate><guid>https://issei1213.github.io/posts/solidjs_types/</guid><description>背景 SolidJSのコンポーネントとイベントハンドラの型定義について悩んでいたが、公式で解説が乗っていたので、
個人的にまとめることにする。
概要 コンポーネントとイベントハンドラの型定義の方法をまとめていく。
公式ではコンポーネントの型をComponent Types、エベントハンドラの型をEvent Handlersとして記載しているので、 同一の単語を使用していく。
本題 Component Types Component import type { JSX, Component } from &amp;#39;solid-js&amp;#39;; type Component&amp;lt;P = {}&amp;gt; = (props: P) =&amp;gt; JSX.Element; 基本的にはReactのFCと同じような使い型ができ、propsの型をジェネリクスで定義することができる。
戻り値はJSX.Elementになる。
サンプルコード　※公式のコードを参照
import { render } from &amp;#34;solid-js/web&amp;#34;; import { createSignal, Component } from &amp;#34;solid-js&amp;#34;; const Counter: Component = () =&amp;gt; { const [count, setCount] = createSignal(0); return ( &amp;lt;button onClick={() =&amp;gt; setCount((c) =&amp;gt; c+1)}&amp;gt; {count()} &amp;lt;/button&amp;gt; ); }; const InitCounter: Component&amp;lt;{initial: number}&amp;gt; = (props) =&amp;gt; { const [count, setCount] = createSignal(props.</description></item><item><title>TypeScript Tip #20</title><link>https://issei1213.github.io/posts/typescript_tip-20/</link><pubDate>Wed, 20 Apr 2022 23:30:11 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-20/</guid><description>背景 今回もmattさんのTypeScriptTipsを解説していく。
TypeScript Tip #20
概要 以下のオブジェクトの型が存在している時に、特定のキーのバリューのユニオンを作成する時に使用する。
export type Obj = { a: &amp;#39;a&amp;#39;, a2: &amp;#39;a2&amp;#39;, a3: &amp;#39;a3&amp;#39;, b: &amp;#39;b&amp;#39;, b1: &amp;#39;b1&amp;#39;, b2: &amp;#39;b2&amp;#39; } // 上記の型から以下の型を作成したい type NewUnion = &amp;#34;a&amp;#34; | &amp;#34;a2&amp;#34; | &amp;#34;a3&amp;#34; 本題 以下が実際の型定義になる。順番に解説していく。
type ValuesOfKeysStartingWithA&amp;lt;Obj&amp;gt; = { [K in Extract&amp;lt;keyof Obj, `a${string}`&amp;gt;]: Obj[K]; }[Extract&amp;lt;keyof Obj, `a${string}`&amp;gt;] type NewUnion = ValuesOfKeysStartingWithA&amp;lt;Obj&amp;gt; // type NewUnion = &amp;#34;a&amp;#34; | &amp;#34;a2&amp;#34; | &amp;#34;a3&amp;#34; 今回のポイントはExtract&amp;lt;keyof Obj,`a${string}`&amp;gt;になるため細かくみていく。 まず、a${string}がどのように型定義されるかというと、文字列aを含めて文字列リテラル型を定義できる。 type TestType = `a${string}` // Success const test1: TestType = &amp;#39;a&amp;#39; const test2: TestType = &amp;#39;a1&amp;#39; // Error const test3: TestType = &amp;#39;1&amp;#39; // Type &amp;#39;&amp;#34;1&amp;#34;&amp;#39; is not assignable to type &amp;#39;`a${string}`&amp;#39;.</description></item><item><title>TypeScript Tip #8</title><link>https://issei1213.github.io/posts/typescript_tip-8/</link><pubDate>Fri, 15 Apr 2022 00:14:16 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-8/</guid><description>背景 今回もmattさんのTypeScriptTipsをまとめていく。
TypeScript Tip #8
概要 Reactのジェネリクスを使用して、動的で柔軟なコンポーネントを作成することができる。
本題 以下のコードはReactのサンプルのコードである。
Tableコンポーネントのpropsに存在するitemsはオブジェクトの配列になっている。
オブジェクトはプロパティidのみを保持している。
import React from &amp;#39;react&amp;#39; interface TableProps { items: { id: string }[] renderItem: (item: { id: string }) =&amp;gt; React.ReactNode } export const Table = (props: TableProps) =&amp;gt; { return null } const Component = () =&amp;gt; { return ( &amp;lt;Table items={[ { id: &amp;#39;1&amp;#39;, } ]} renderItem={(item) =&amp;gt; &amp;lt;div&amp;gt;{ item.id }&amp;lt;/div&amp;gt;} &amp;gt;&amp;lt;/Table&amp;gt; ) } 上記の場合、propsitemsにオブジェクトのid以外のプロパティを定義したい場合、TablePropsにも追加をしてやる必要がある。 以下はそのサンプルコード</description></item><item><title>TypeScript Tip #7</title><link>https://issei1213.github.io/posts/typescript_tip-7/</link><pubDate>Wed, 13 Apr 2022 23:11:35 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-7/</guid><description>背景 今回もmattさんの記事をまとめていく。
TypeScript Tip #7
概要 オブジェクト中身を順番に処理していく時には、以下のコードを用いることがある。
const myObject = { a: 1, b: 2, c: 3 } Object.keys(myObject).forEach((key) =&amp;gt; { console.log(myObject[key]) // Element implicitly has an &amp;#39;any&amp;#39; type because expression of type &amp;#39;string&amp;#39; can&amp;#39;t be used to index type &amp;#39;{ a: number; b: number; c: number; }&amp;#39;. // No index signature with a parameter of type &amp;#39;string&amp;#39; was found on type &amp;#39;{ a: number; b: number; c: number; }&amp;#39;.</description></item><item><title>TypeScript Tip #5</title><link>https://issei1213.github.io/posts/typescript_tip-5/</link><pubDate>Sun, 10 Apr 2022 12:43:14 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-5/</guid><description>背景 今回もmattさんの動画をまとめていく
TypeScript Tip #5
概要 型推論された型に対してextendsを使用するまとめていく。
本題 実際のサンプルコードは以下。 getDeepValue関数の引数にオブジェクトを渡して、そこから型推論をさせている。
第2引数、第3引数のオブジェクトのキーを指定して、最終的なバリューを取得できるような関数を作成する。
export const getDeepValue = &amp;lt; Obj, FirstKey extends keyof Obj, SecondKey extends keyof Obj[FirstKey] &amp;gt;( obj: Obj, firstKey: FirstKey, secondKey: SecondKey ): Obj[FirstKey][SecondKey] =&amp;gt; { return obj[firstKey][secondKey] } const obj = { foo: { a: true, b: 2 }, bar: { c: &amp;#39;cool&amp;#39;, d: 2 } } console.log(getDeepValue(obj, &amp;#39;bar&amp;#39;, &amp;#39;d&amp;#39;)) 引数の第2引数FirstKeyは型推論されたObjに制約を設けている。 FirstKey extends keyof { foo: { a: boolean; b: number; }; bar: { c: string; d: number; }; } 🔽 FirstKey extends &amp;#34;foo&amp;#34; | &amp;#34;bar&amp;#34; よって、FirstKeyはfooかbarのどちらかになる。</description></item><item><title>TypeScript Tip #3</title><link>https://issei1213.github.io/posts/typescript_tip-3/</link><pubDate>Sat, 09 Apr 2022 01:13:25 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-3/</guid><description>背景 今回もmattoさんのコードリーディングをしていく。
TypeScript Tip #3
概要 今回はTypeScriptのユーティリティをまとめたライブラリts-toolbeltについて説明していく。
注意点としては、TypeScriptバージョンが4.1以上である必要がある。 数多くのユーティリティが提供されているため、今回はMattさんの解説に絞ってまとめていく。
ts-toolbelt
本題 使い方 ライブラリの中から使用したいユーティリティをimportして使用する。
import { String, Union } from &amp;#39;ts-toolbelt&amp;#39;; 今回はURLの操作をする時に便利なユーティリティをまとめていく。
サンプルコード import { String, Union } from &amp;#39;ts-toolbelt&amp;#39;; const query = &amp;#39;/home?a=foo&amp;amp;b=wow&amp;#39; type Query = typeof query // type Query = &amp;#34;/home?a=foo&amp;amp;b=wow&amp;#34; type SecondQueryPart = String.Split&amp;lt;Query, &amp;#39;?&amp;#39;&amp;gt;[1] // type SecondQueryPart = &amp;#34;a=foo&amp;amp;b=wow&amp;#34; type QueryElements = String.Split&amp;lt;SecondQueryPart, &amp;#39;&amp;amp;&amp;#39;&amp;gt; // type QueryElements = [&amp;#34;a=foo&amp;#34;, &amp;#34;b=wow&amp;#34;] type QueryParams = { [ QueryElement in QueryElements[number] ]: { [ key in String.</description></item><item><title>TypeScript Tip #2</title><link>https://issei1213.github.io/posts/typescript_tip-2/</link><pubDate>Fri, 08 Apr 2022 20:26:20 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-2/</guid><description>背景 今回もmattoさんのTypeScriptの動画をまとめていく
概要 下記の様なEntityの型を定義する。
type Entity = | { type: &amp;#39;user&amp;#39; } | { type: &amp;#39;post&amp;#39; } | { type: &amp;#39;comment&amp;#39; } 上記の型の各オブジェクトにidを追加したい。その時のコードは以下になる。
typeに応じたidのプロパティを追加している。
type EntityWithId = | { type: &amp;#39;user&amp;#39; userId: string } | { type: &amp;#39;post&amp;#39; postId: string } | { type: &amp;#39;comment&amp;#39; commentId: string } const result1: EntityWithId = { type: &amp;#39;post&amp;#39;, postId: &amp;#39;123&amp;#39; } const result2: EntityWithId = { type: &amp;#39;user&amp;#39;, userId: &amp;#39;123&amp;#39; } 今回はEntityWithIdの部分をインデックスシグネチャを利用して作成していく。
本題 実際のコードは以下になる。細かくみていく。</description></item><item><title>TypeScript Tip #1</title><link>https://issei1213.github.io/posts/typescript_tip-1/</link><pubDate>Thu, 07 Apr 2022 12:43:39 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-1/</guid><description>背景 前回のmattさんのTypeScript Tip #15が勉強になったので、最初から#1からまとめていく
概要 export const fruitCounts = { apple: 1, pear: 4, banana: 26 } 上記の様なコードがあった時に、特定のキーを取得する型エイリアスで定義すると以下になる。
type SingleFruitCount = | { apple: number } | { banana: number } | { pear: number } const singleFruitCount: SingleFruitCount = { apple: 10, } SingleFruitCountの型エイリアスを作成すれば、型定義できるが定数fruitCountsを型推論させて型エイリアスを作成する。
本題 最終的なコードは以下になる。具体的に解説していく。
type FruitCounts = typeof fruitCounts type NewSingleFruitCount = { [ K in keyof FruitCounts ]: { [ K2 in K ]: number } }[keyof FruitCounts] // type NewSingleFruitCount = { // apple: number; // } | { // pear: number; // } | { // banana: number; // } typeof fruitCountsは型推論が効いて以下の型が作成される。 type FruitCounts = { apple: number; pear: number; banana: number; } [ K in keyof FruitCounts ]のkeyof FruitCountsは型エイリアスのオブジェクトのキーのみを取得することができる。</description></item><item><title>りあクトのTypeScriptサンプルコードリーディング</title><link>https://issei1213.github.io/posts/typescript_react-sample-code-reading/</link><pubDate>Sat, 02 Apr 2022 13:39:20 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_react-sample-code-reading/</guid><description>背景 TypeScriptの教材で以下のサンプルコードがあったので、コードリーディングしていく。
概要 以下のコードリーディングをしていく。
非同期データ取得関数をラップして、そこで起きる例外をフォローしつつ正常系と異常系に振り分ける関数を定義している。
type Result&amp;lt;T, E extends Error&amp;gt; = Ok&amp;lt;T, E&amp;gt; | Err&amp;lt;T, E&amp;gt; export class Ok&amp;lt;T, E extends Error&amp;gt; { constructor(readonly val: T) {} isOk = (): this is Ok&amp;lt;T, E&amp;gt; =&amp;gt; true isErr = (): this is Err&amp;lt;T, E&amp;gt; =&amp;gt; false } export class Err&amp;lt;T, E extends Error&amp;gt; { constructor(readonly err: E) {} isOk = (): this is Ok&amp;lt;T, E&amp;gt; =&amp;gt; false isErr = (): this is Err&amp;lt;T, E&amp;gt; =&amp;gt; true } export const withResult = &amp;lt;T, A extends any[], E extends Error&amp;gt;(fn: (.</description></item><item><title>TypeScript Tip #15</title><link>https://issei1213.github.io/posts/typescript_tip-15/</link><pubDate>Fri, 01 Apr 2022 23:23:48 +0900</pubDate><guid>https://issei1213.github.io/posts/typescript_tip-15/</guid><description>背景 Twitterを眺めていると汎用性が高そうな関数を作成できるTypeScriptのツイートがあったので、整理するためにまとめる。
TypeScript Tip #15 概要 関数の引数のタイプをみて、タイプに応じてpayloadが必要か必要がないかをTypeScriptで判断する。
// 第一引数がSIGN_OUTの場合は、payloadはなし sendEvent(&amp;#39;SIGN_OUT&amp;#39;) // 第一引数がLOG_INの場合は、payloadは必須 sendEvent(&amp;#34;LOG_IN&amp;#34;, { userId: &amp;#39;123&amp;#39; }) 成功パターン
sendEvent(&amp;#39;SIGN_OUT&amp;#39;) sendEvent(&amp;#34;LOG_IN&amp;#34;, { userId: &amp;#39;123&amp;#39; }) 失敗パターン(コンパイルエラー)
sendEvent(&amp;#39;SIGN_OUT&amp;#39;, {}) sendEvent(&amp;#39;LOG_IN&amp;#39;, { userId: 122 }) sendEvent(&amp;#39;LOG_IN&amp;#39;, {}) sendEvent(&amp;#39;LOG_IN&amp;#39;) 本題 以下のコードで実現可能
type AuthEvent = | { type: &amp;#39;LOG_IN&amp;#39; payload: { userId: string } } | { type: &amp;#39;SIGN_OUT&amp;#39; } const sendEvent = &amp;lt;Type extends AuthEvent[&amp;#39;type&amp;#39;]&amp;gt;( ...args: Extract&amp;lt;AuthEvent, { type: Type }&amp;gt; extends { payload: infer TPayload } ?</description></item></channel></rss>